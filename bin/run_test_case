#!/bin/bash

#
# Some of these variables come from 'run_all_tests' ...
#
export ERR_FILE=${RESULT_DIR}/error_output
export SUM_FILE=${RESULT_DIR}/${TEST_NUM}_summary
export DET_FILE=${RESULT_DIR}/${TEST_NUM}_detail

# At the moment things sometimes file the first time. This
# just allows us to try one more time.
RUNONCE=$1

#
# Run the test using 'gaiatest', ignore STDOUT (because what we want is being
# writtin to a file), but capture STDERR.
#
x=$(gaiatest --address localhost:2828 $TEST_FILE > /dev/null 2>$ERR_FILE)

#
# Now append any Marionette output to the details file (sometimes it contains
# 'issues' that we don't catch).
#
x=$(grep -i error $ERR_FILE)
if [ "$x" ]
then
    echo "


################################################################################
#
# OUTPUT FROM MARIONETTE ....
# ===========================
#

$(cat $ERR_FILE)
" >> $DET_FILE

fi

#
# Display the summary file.
# If there is an 'error' in the marionette output but we think our tests
# passed, this indicates a possible error with our test code.
#
# (uncomment this to stop it trying failed tests twice.)
#RUNONCE="Y"
cat $SUM_FILE | while read line
do

    result=$(echo $line | awk '{print $NF}')
    if [ "$result" = "Passed" ]
    then
        x="$line"
        y=$(grep -i error $ERR_FILE)
        if [ "$y" ]
        then
            x="$x (NOTE: possible test code error!)"
        fi
        echo "$x"
    else
        #
        # It failed - at the moment, failures are usually just
        # 'something odd' in Marionette or Gaiatest, which run
        # fine the next time you try.
        # Because this is so often the case, we'll automatically
        # Try a second time before giving up.
        #
        if [ "$RUNONCE" = "Y" ]
        then
            # This is the 2nd atempt - report the error because it's real.
            echo "$line"
        else
            # Try again.
            $0 Y
        fi
    fi
    RUNONCE=""
done
